package com.steinwurf.score_android_server_reference;

import android.annotation.SuppressLint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaFormat;
import android.os.Build;
import android.os.Handler;
import android.support.annotation.NonNull;
import android.util.Log;
import android.util.Size;
import android.view.Surface;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Collections;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

class Camera {

    private Thread mEncoderThread;

    public interface OnDataListener {
        void onData(ByteBuffer data);
        void onFinish();
    }

    /**
     * Tag for the {@link Log}.
     */
    private static final String TAG = Camera.class.getSimpleName();

    /**
     * The MIME type for the video mEncoder
     */
    private static final String MIME_TYPE = "video/avc";
    private static final int WIDTH = 1280;
    private static final int HEIGHT = 720;
    private static final int BIT_RATE = 2000000;
    private static final int FRAME_RATE = 30;
    private static final int I_FRAME_INTERVAL = 1;
    private final OnDataListener onDataListener;

    /**
     * Encoder for encoding the data from the camera
     */
    private MediaCodec mEncoder;

    /**
     * A {@link CameraCaptureSession } for camera preview.
     */
    private CameraCaptureSession mCaptureSession;

    /**
     * A reference to the opened {@link CameraDevice}.
     */
    private CameraDevice mCameraDevice;

    /**
     * The {@link android.util.Size} of camera preview.
     */
    private Size mSize;

    /**
     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.
     */
    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {

        @Override
        public void onOpened(@NonNull CameraDevice cameraDevice) {
            // This method is called when the camera is opened.  We start camera preview here.
            mCameraOpenCloseLock.release();
            mCameraDevice = cameraDevice;
            try {
                createCameraCaptureSession();
            } catch (CameraAccessException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice cameraDevice) {
            mCameraOpenCloseLock.release();
            cameraDevice.close();
            mCameraDevice = null;
        }

        @Override
        public void onError(@NonNull CameraDevice cameraDevice, int error) {
            mCameraOpenCloseLock.release();
            cameraDevice.close();
            mCameraDevice = null;
            // todo maybe onError callback
        }

    };

    /**
     * A {@link Handler} for running tasks in the background.
     */
    private BackgroundHandler mBackgroundHandler = new BackgroundHandler();

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    private CaptureRequest.Builder mCaptureRequestBuilder;

    /**
     * {@link CaptureRequest} generated by {@link #mCaptureRequestBuilder}
     */
    private CaptureRequest mCaptureRequest;

    /**
     * The camera's output surface and the mEncoder's input surface
     */
    private Surface mSurface;

    /**
     * A {@link Semaphore} to prevent the app from exiting before closing the camera.
     */
    private Semaphore mCameraOpenCloseLock = new Semaphore(1);

    Camera(OnDataListener onDataListener)
    {
        this.onDataListener = onDataListener;
    }

    void start(CameraManager manager) throws IOException {
        startEncoder();
        mBackgroundHandler.start();
        openCamera(manager);
    }

    void stop() {
        closeCamera();
        mBackgroundHandler.stop();
        stopEncoder();
    }

    private void startEncoder() throws IOException {
        MediaFormat format =
                MediaFormat.createVideoFormat(MIME_TYPE, WIDTH, HEIGHT);
        format.setInteger(MediaFormat.KEY_COLOR_FORMAT,
                MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
        format.setInteger(MediaFormat.KEY_BIT_RATE, BIT_RATE);
        format.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);
        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, I_FRAME_INTERVAL);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
        {
            format.setInteger(MediaFormat.KEY_PRIORITY, /*real time*/0);
        }
        mEncoder = MediaCodec.createEncoderByType(MIME_TYPE);
        mEncoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
        mSurface = mEncoder.createInputSurface();
        mEncoder.start();
        mEncoderThread = new Thread(drainEncoder);
        mEncoderThread.start();
    }

    /**
     * Opens the camera specified by the given id.
     */
    @SuppressLint("MissingPermission")
    private void openCamera(CameraManager manager) {
        try {
            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw new RuntimeException("Time out waiting to lock camera opening.");
            }

            // Just pick the first camera
            String cameraId = manager.getCameraIdList()[0];

            manager.openCamera(cameraId, mStateCallback, mBackgroundHandler.getHandler());
        } catch (CameraAccessException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
        }
    }

    /**
     * Closes the current {@link CameraDevice}.
     */
    private void closeCamera() {
        try {
            mCameraOpenCloseLock.acquire();
            if (null != mCaptureSession) {
                mCaptureSession.close();
                mCaptureSession = null;
            }
            if (null != mCameraDevice) {
                mCameraDevice.close();
            }
            mCameraDevice = null;

            if (mSurface != null)
            {
                mSurface.release();
                mSurface = null;
            }

        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            mCameraOpenCloseLock.release();
        }
    }

    private void stopEncoder() {
        if (mEncoder != null) {
            // Signal end of stream
            mEncoder.signalEndOfInputStream();
            try {
                mEncoderThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            mEncoder.stop();
            mEncoder.reset();
            if (mSurface != null)
            {
                mSurface.release();
                mSurface = null;
            }
            mEncoder.release();
            mEncoder = null;
        }
    }

    /**
     * Creates a new {@link CameraCaptureSession} for camera preview.
     */
    private void createCameraCaptureSession() throws CameraAccessException {
        if (mCameraOpenCloseLock.tryAcquire()) {
            // We set up a CaptureRequest.Builder with the output Surface.
            mCaptureRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
            mCaptureRequestBuilder.addTarget(mSurface);
            mCaptureRequestBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);

            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice.createCaptureSession(Collections.singletonList(mSurface),
                    new CameraCaptureSession.StateCallback() {

                        @Override
                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {
                            // The camera is already closed
                            if (null == mCameraDevice) {
                                return;
                            }

                            // When the session is ready, we start displaying the preview.
                            mCaptureSession = cameraCaptureSession;
                            try {
                                // Auto focus should be continuous for camera preview.
                                mCaptureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

                                // Finally, we start displaying the camera preview.
                                mCaptureRequest = mCaptureRequestBuilder.build();

                                mCaptureSession.setRepeatingRequest(mCaptureRequest, new CameraCaptureSession.CaptureCallback() {
                                    @Override
                                    public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) {
                                        super.onCaptureStarted(session, request, timestamp, frameNumber);

                                    }
                                }, mBackgroundHandler.getHandler());
                            } catch (CameraAccessException e) {
                                e.printStackTrace();
                            }
                            mCameraOpenCloseLock.release();
                        }

                        @Override
                        public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) {
                        }
                    }, null
            );
        }
    }

    private Runnable drainEncoder = new Runnable() {
        @Override
        public void run() {
            MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
            while (true) {
                int encoderStatus = mEncoder.dequeueOutputBuffer(bufferInfo, 10000);
                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
//                    Log.i(TAG, "no output available, spinning");
                    bufferInfo = new MediaCodec.BufferInfo();
                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                    MediaFormat newFormat = mEncoder.getOutputFormat();
//                    Log.d(TAG, "output format changed");
                } else if (encoderStatus >= 0) {
//                    Log.i(TAG, "output available");
                    // Normal flow: get output encoded buffer, send to VideoDataCallback
                    ByteBuffer videoData = mEncoder.getOutputBuffer(encoderStatus);
                    assert videoData != null;
                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
                        /*
                         * The codec config data was pulled out and fed to the VideoDataCallback
                         * when we got the INFO_OUTPUT_FORMAT_CHANGED status. Ignore it.
                         */
                        bufferInfo.size = 0;
                    }
                    if (bufferInfo.size != 0) {
                        // It's usually necessary to adjust the ByteBuffer values to match BufferInfo.
                        videoData.position(bufferInfo.offset);
                        videoData.limit(bufferInfo.offset + bufferInfo.size);
                        ByteBuffer data = ByteBuffer.allocate(bufferInfo.size + Long.SIZE / Byte.SIZE);
                        data.order(ByteOrder.BIG_ENDIAN);
                        data.putLong(bufferInfo.presentationTimeUs);
                        data.put(videoData);
                        onDataListener.onData(data);
                    }
                    mEncoder.releaseOutputBuffer(encoderStatus, false);
                    if ((bufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        onDataListener.onFinish();
                        return;
                    }
                } else {
//                    Log.w(TAG, "unexpected result from mEncoder.dequeueOutputBuffer: " + encoderStatus);
                }
            }
        }
    };
}
